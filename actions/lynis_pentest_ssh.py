"""
lynis_pentest_ssh.py - Executes a Lynis pentest audit on hosts with confirmed SSH credentials.
"""

import os
import time
import logging
import paramiko
from datetime import datetime
from typing import Any, Dict, List
from shared import SharedData
from logger import Logger
from lynis_parser import parse_lynis_dat


logger = Logger(name="lynis_pentest_ssh.py", level=logging.DEBUG)

b_class = "LynisPentestSSH"
b_module = "lynis_pentest_ssh"
b_status = "lynis_pentest_ssh"
b_parent = "SSHBruteforce"
b_port = 22


class LynisPentestSSH:
	"""Run Lynis in pentest mode against hosts compromised via SSH."""

	def __init__(self, shared_data):
		self.shared_data = shared_data
		self.ssh_timeout = 25
		self.command_timeout = 900  # Lynis can take a while
		self.progress_callback = None
		logger.info("LynisPentestSSH initialized")

	def execute(self, ip, port, row, status_key):
		try:
			parent_status = row.get(getattr(self, 'b_parent_action', ''), '')
			if 'success' not in parent_status:
				logger.info(f"Skipping Lynis audit for {ip}; parent action not successful")
				return 'failed'

			credentials = self._load_credentials(ip)
			if not credentials:
				logger.warning(f"No SSH credentials available for {ip}; cannot run Lynis")
				return 'failed'

			self.shared_data.ragnarorch_status = b_class
			time.sleep(2)

			os.makedirs(self.shared_data.vulnerabilities_dir, exist_ok=True)
			return self._execute_with_credentials(ip, credentials)
		except Exception as exc:
			logger.error(f"Unexpected LynisPentestSSH error for {ip}:{port}: {exc}")
			return 'failed'

	def run_manual(self, ip, username, password, progress_callback=None):
		"""Run a Lynis pentest directly with provided credentials."""
		try:
			self.progress_callback = progress_callback
			self.shared_data.ragnarorch_status = b_class
			time.sleep(1)
			os.makedirs(self.shared_data.vulnerabilities_dir, exist_ok=True)
			return self._execute_with_credentials(ip, [(username, password)])
		except Exception as exc:
			logger.error(f"Manual Lynis execution failed for {ip}: {exc}")
			return 'failed'

	# ------------------------------------------------------------------
	# Helper functions
	# ------------------------------------------------------------------

	def _execute_with_credentials(self, ip, credentials):
		if not credentials:
			logger.warning(f"No credentials supplied for Lynis run on {ip}")
			return 'failed'

		for username, password in credentials:
			if self.shared_data.orchestrator_should_exit:
				logger.info("Orchestrator requested stop; aborting Lynis runs")
				break
			try:
				if self.progress_callback:
					self.progress_callback('connecting', {
						'message': f'Connecting to {ip} via SSH...',
						'stage': 'connection',
						'details': f'Using credentials: {username}'
					})
				
				with self._connect(ip, username, password) as ssh:
					if self.progress_callback:
						self.progress_callback('connected', {
							'message': 'SSH connection established',
							'stage': 'setup',
							'details': 'Checking Lynis availability'
						})
					
					if not self._ensure_lynis_available(ssh, password):
						continue
						
					if self.progress_callback:
						self.progress_callback('audit_starting', {
							'message': 'Starting Lynis security audit...',
							'stage': 'audit',
							'details': 'Running system audit in pentest mode'
						})
					
					run_result = self._run_lynis(ssh, password, ip, username)
					if run_result:
						if self.progress_callback:
							self.progress_callback('processing', {
								'message': 'Processing audit results...',
								'stage': 'processing',
								'details': 'Downloading and analyzing report'
							})
						
						logger.success(
							f"Lynis pentest report saved for {ip} using {username}: {run_result['text_report']}"
						)
						self._handle_full_report(ssh, password, ip, run_result['timestamp'])
						return 'success'
			except Exception as exc:
				logger.error(f"Lynis run failed for {ip} with {username}: {exc}")

		logger.error(f"Unable to produce Lynis report for {ip}")
		return 'failed'

	def _load_credentials(self, ip):
		creds = []
		if not os.path.exists(self.shared_data.sshfile):
			return creds
		try:
			with open(self.shared_data.sshfile, 'r', encoding='utf-8') as handle:
				lines = handle.readlines()[1:]
			for line in lines:
				parts = line.strip().split(',')
				if len(parts) < 5:
					continue
				if parts[1] == ip:
					creds.append((parts[3], parts[4]))
		except Exception as exc:
			logger.error(f"Error reading SSH credentials for {ip}: {exc}")
		return creds

	def _connect(self, ip, username, password):
		ssh = paramiko.SSHClient()
		ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
		ssh.connect(
			ip,
			port=b_port,
			username=username,
			password=password,
			timeout=self.ssh_timeout,
			auth_timeout=self.ssh_timeout,
			banner_timeout=self.ssh_timeout
		)
		logger.info(f"SSH session ready for Lynis on {ip} using {username}")
		return ssh

	def _run_remote_command(self, ssh, command, password=None, sudo=False, timeout=None):
		full_command = command if not sudo else f"sudo -S -p '' {command}"
		stdin, stdout, stderr = ssh.exec_command(full_command, get_pty=True, timeout=timeout or self.command_timeout)
		if sudo and password:
			stdin.write(f"{password}\n")
			stdin.flush()
		exit_code = stdout.channel.recv_exit_status()
		output = stdout.read().decode(errors='ignore')
		error = stderr.read().decode(errors='ignore')
		return exit_code, output.strip(), error.strip()

	def _ensure_lynis_available(self, ssh, password):
		exit_code, _, _ = self._run_remote_command(ssh, "command -v lynis")
		if exit_code == 0:
			if self.progress_callback:
				self.progress_callback('lynis_found', {
					'message': 'Lynis found on target system',
					'stage': 'setup',
					'details': 'Lynis is already installed'
				})
			return True

		logger.info("Lynis not found on target; installing via apt-get")
		if self.progress_callback:
			self.progress_callback('installing', {
				'message': 'Installing Lynis on target...',
				'stage': 'setup',
				'details': 'Running apt-get update and install'
			})
			
		commands = [
			"apt-get update",
			"DEBIAN_FRONTEND=noninteractive apt-get install -y lynis"
		]

		for cmd in commands:
			exit_code, out, err = self._run_remote_command(ssh, cmd, password=password, sudo=True, timeout=600)
			if exit_code != 0:
				logger.error(f"Command '{cmd}' failed during Lynis install: {err or out}")
				return False
		return True

	def _run_lynis(self, ssh, password, ip, username):
		timestamp = datetime.utcnow().strftime('%Y%m%d_%H%M%S')
		remote_log = f"/tmp/lynis-pentest-{timestamp}.log"
		audit_cmd = f"lynis audit system --pentest --quiet --logfile {remote_log}"

		logger.info(f"Running Lynis pentest on {ip} as {username}")
		exit_code, out, err = self._run_remote_command(
			ssh,
			audit_cmd,
			password=password,
			sudo=True,
			timeout=self.command_timeout
		)

		if exit_code != 0:
			logger.error(f"Lynis audit failed on {ip}: {err or out}")
			return None

		# Fix permissions on the log file so we can download it
		# The log file was created by root (via sudo), so we need to change ownership or permissions
		chmod_exit_code, _, chmod_err = self._run_remote_command(
			ssh,
			f"chmod 644 {remote_log}",
			password=password,
			sudo=True,
			timeout=30
		)
		
		if chmod_exit_code != 0:
			logger.warning(f"Failed to fix permissions on {remote_log}: {chmod_err}")
			# Try alternative: copy file to user-writable location
			user_log = f"/tmp/lynis-pentest-{username}-{timestamp}.log"
			copy_exit_code, _, copy_err = self._run_remote_command(
				ssh,
				f"cp {remote_log} {user_log} && chown {username}:{username} {user_log}",
				password=password,
				sudo=True,
				timeout=30
			)
			if copy_exit_code == 0:
				remote_log = user_log  # Use the copied file instead
				logger.info(f"Copied Lynis log to user-accessible location: {user_log}")
			else:
				logger.error(f"Failed to copy log file: {copy_err}")

		report_text = self._fetch_remote_file(ssh, remote_log)
		if not report_text:
			report_text = (out or '') + ("\n" + err if err else '')
		else:
			report_text = report_text + ("\n\n--- STDOUT ---\n" + out if out else '')

		local_report = os.path.join(
			self.shared_data.vulnerabilities_dir,
			f"lynis_{ip}_{timestamp}_pentest.txt"
		)

		header = (
			f"Lynis Pentest Report\nTarget: {ip}\nUser: {username}\n"
			f"Generated (UTC): {datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S')}\n"
			f"Command: lynis audit system --pentest\n\n"
		)

		with open(local_report, 'w', encoding='utf-8') as handle:
			handle.write(header)
			handle.write(report_text)

		logger.debug(f"Stored Lynis report at {local_report}")
		return {
			'text_report': local_report,
			'timestamp': timestamp
		}

	def _handle_full_report(self, ssh, password, ip, timestamp):
		try:
			result = self._download_full_report(ssh, password, ip, timestamp)
			if not result:
				return
			local_path, parsed = result
			if parsed:
				self._record_network_findings(ip, parsed, local_path)
		except Exception as exc:
			logger.error(f"Failed to process full Lynis report for {ip}: {exc}")

	def _download_full_report(self, ssh, password, ip, timestamp):
		# Get the current username to ensure proper ownership
		username_cmd = "whoami"
		_, current_user, _ = self._run_remote_command(ssh, username_cmd)
		current_user = current_user.strip() or "pi"  # fallback to pi
		
		remote_temp = f"/tmp/lynis-report-{timestamp}.dat"
		# Copy the report file and ensure proper permissions and ownership
		copy_cmd = (
			f"bash -c 'cp /var/log/lynis-report.dat {remote_temp} && "
			f"chown {current_user}:{current_user} {remote_temp} && "
			f"chmod 644 {remote_temp}'"
		)
		exit_code, out, err = self._run_remote_command(
			ssh,
			copy_cmd,
			password=password,
			sudo=True,
			timeout=60
		)
		if exit_code != 0:
			error_message = (err or out or 'unknown error').strip()
			if password:
				error_message = error_message.replace(password, '***')
			logger.error(f"Unable to copy full Lynis report: {error_message}")
			return None

		report_content = self._fetch_remote_file(ssh, remote_temp)
		if not report_content:
			logger.error("Full Lynis report was empty or missing after copy")
			return None

		local_path = os.path.join(
			self.shared_data.vulnerabilities_dir,
			f"lynis_{ip}_{timestamp}.dat"
		)
		with open(local_path, 'w', encoding='utf-8') as handle:
			handle.write(report_content)

		parsed_dict: Dict[str, Any] = parse_lynis_dat(report_content) or {}
		warnings: List[Dict[str, Any]] = list(parsed_dict.get('warnings', []))
		suggestions: List[Dict[str, Any]] = list(parsed_dict.get('suggestions', []))
		packages: List[Dict[str, Any]] = list(parsed_dict.get('vulnerable_packages', []))
		logger.info(
			f"Stored full Lynis report at {local_path}; warnings={len(warnings)}, "
			f"suggestions={len(suggestions)}, packages={len(packages)}"
		)
		parsed_dict['warnings'] = warnings
		parsed_dict['suggestions'] = suggestions
		parsed_dict['vulnerable_packages'] = packages
		return local_path, parsed_dict

	def _record_network_findings(self, ip, parsed_report, report_path):
		network_intel = getattr(self.shared_data, 'network_intelligence', None)
		if not network_intel:
			logger.warning("Network intelligence not initialized; skipping Lynis ingestion")
			return

		total_findings = 0

		for entry in parsed_report.get('warnings', []):
			message = (entry.get('message') or entry.get('raw') or '').strip()
			code = (entry.get('code') or 'WARNING').strip()
			vuln_id = network_intel.add_vulnerability(
				host=ip,
				port=0,
				service='lynis',
				vulnerability=f"[{code}] {message}".strip(),
				severity='high',
				details={
					'lynis_type': 'warning',
					'code': entry.get('code'),
					'message': message,
					'detail': entry.get('detail'),
					'remediation': entry.get('remediation'),
					'source_file': report_path
				}
			)
			if vuln_id:
				total_findings += 1

		for entry in parsed_report.get('suggestions', []):
			message = (entry.get('message') or entry.get('raw') or '').strip()
			code = (entry.get('code') or 'SUGGESTION').strip()
			vuln_id = network_intel.add_vulnerability(
				host=ip,
				port=0,
				service='lynis',
				vulnerability=f"[{code}] {message}".strip(),
				severity='medium',
				details={
					'lynis_type': 'suggestion',
					'code': entry.get('code'),
					'message': message,
					'detail': entry.get('detail'),
					'remediation': entry.get('remediation'),
					'source_file': report_path
				}
			)
			if vuln_id:
				total_findings += 1

		for entry in parsed_report.get('vulnerable_packages', []):
			package = (entry.get('package') or entry.get('raw') or '').strip()
			vuln_id = network_intel.add_vulnerability(
				host=ip,
				port=0,
				service='lynis-packages',
				vulnerability=f"[PACKAGE] {package}",
				severity='high',
				details={
					'lynis_type': 'package',
					'package': entry.get('package'),
					'version': entry.get('version'),
					'status': entry.get('status'),
					'reference': entry.get('reference'),
					'source_file': report_path
				}
			)
			if vuln_id:
				total_findings += 1

		if total_findings:
			logger.info(f"Recorded {total_findings} Lynis findings for {ip} into network intelligence")
		else:
			logger.info(f"Lynis full report for {ip} produced no actionable findings")

	def _fetch_remote_file(self, ssh, remote_path):
		try:
			# First check if the file exists and get its info
			sftp = ssh.open_sftp()
			try:
				file_stat = sftp.stat(remote_path)
				logger.debug(f"Remote file {remote_path}: size={file_stat.st_size}, permissions={oct(file_stat.st_mode)}")
			except Exception as stat_err:
				logger.warning(f"Could not stat remote file {remote_path}: {stat_err}")
			
			with sftp.open(remote_path, 'r') as remote_file:
				data = remote_file.read().decode(errors='ignore')
			
			# Clean up the temporary file
			try:
				sftp.remove(remote_path)
				logger.debug(f"Cleaned up remote file: {remote_path}")
			except Exception as cleanup_err:
				logger.warning(f"Could not remove remote file {remote_path}: {cleanup_err}")
				
			sftp.close()
			logger.info(f"Successfully downloaded {len(data)} bytes from {remote_path}")
			return data
			
		except FileNotFoundError:
			logger.warning(f"Remote Lynis log not found at {remote_path}")
			return ''
		except PermissionError as perm_err:
			logger.error(f"Permission denied accessing {remote_path}: {perm_err}")
			return ''
		except Exception as exc:
			logger.error(f"Error downloading Lynis log {remote_path}: {exc}")
			return ''


if __name__ == "__main__":
	shared = SharedData()
	action = LynisPentestSSH(shared)
	logger.info("LynisPentestSSH module ready")
